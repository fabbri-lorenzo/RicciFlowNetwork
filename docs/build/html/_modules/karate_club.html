<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>karate_club &#8212; Ricci Flow in Networks 01/03/2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=fbff3254"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for karate_club</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">GraphRicciCurvature.OllivierRicci</span><span class="w"> </span><span class="kn">import</span> <span class="n">OllivierRicci</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.colors</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mcolors</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">utils.plot</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphDrawer</span><span class="p">,</span> <span class="n">plot_accuracy</span><span class="p">,</span> <span class="n">plot_comp_histo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">utils.surgery</span><span class="w"> </span><span class="kn">import</span> <span class="n">ARI</span><span class="p">,</span> <span class="n">check_accuracy</span><span class="p">,</span> <span class="n">perform_surgery</span>

<span class="c1"># Custom colormap for Karate club nodes</span>
<span class="n">node_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;purple&quot;</span><span class="p">,</span> <span class="s2">&quot;orange&quot;</span><span class="p">]</span>
<span class="n">nodes_cmap</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">node_colors</span><span class="p">)</span>


<div class="viewcode-block" id="karate_club_rf">
<a class="viewcode-back" href="../karate_club.html#karate_club.karate_club_rf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">karate_club_rf</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function runs a series of tests on Zachary&#39;s Karate Club graph (see https://doi.org/10.1086/jar.33.4.3629752) to compute the Ollivier-Ricci curvature, perform Ricci flow, and evaluate the modularity and accuracy after surgery.</span>

<span class="sd">    Steps:</span>
<span class="sd">    1. Load the Karate Club graph.</span>
<span class="sd">    2. Compute the Ollivier-Ricci curvature of the graph.</span>
<span class="sd">    3. Apply Ricci flow to the graph.</span>
<span class="sd">    4. Compute modularity and ARI (Adjusted Rand Index) based on the cutoff parameter.</span>
<span class="sd">    5. Perform edge surgery based on a user-defined threshold (i.e. the chosen cutoff).</span>
<span class="sd">    6. Detect communities as connected components of the resulting graph.</span>
<span class="sd">    7. Draw and save visualizations for each of the steps.</span>

<span class="sd">    The resulting images and accuracy plots are saved to a directory called &#39;KarateClubResults&#39;.</span>

<span class="sd">    :returns: A tuple containing:</span>
<span class="sd">        - **best_mod** (*float*): Modularity value corrensponding to highest ari.</span>
<span class="sd">        - **best_ari** (*float*): Highest Adjusted Rand Index obtained applying Ricci Flow.</span>
<span class="sd">    :rtype: tuple(float, float)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Import karate club graph&quot;</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>

    <span class="n">save_path</span> <span class="o">=</span> <span class="s2">&quot;KarateClubResults&quot;</span>
    <span class="c1"># -----------------------------------</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=====  Compute Ricci flow metric - Optimal Transportation Distance =====&quot;</span><span class="p">)</span>
    <span class="n">orc</span> <span class="o">=</span> <span class="n">OllivierRicci</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;OTD&quot;</span><span class="p">)</span>

    <span class="n">orc</span><span class="o">.</span><span class="n">compute_ricci_curvature</span><span class="p">()</span>

    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">orc</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;Before Ricci Flow&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">plot_graph_histo</span><span class="p">()</span>
    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">orc</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;Before Ricci Flow (graph)&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">draw_graph</span><span class="p">(</span>
        <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;club&quot;</span><span class="p">,</span> <span class="n">nodes_cmap</span><span class="o">=</span><span class="n">nodes_cmap</span>
    <span class="p">)</span>
    <span class="c1"># -----------------------------------</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=====  Perform Ricci flow =====&quot;</span><span class="p">)</span>

    <span class="n">orc</span><span class="o">.</span><span class="n">compute_ricci_flow</span><span class="p">(</span><span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">G_rf</span> <span class="o">=</span> <span class="n">orc</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">G_rf</span><span class="p">,</span> <span class="s2">&quot;After Ricci Flow&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">plot_graph_histo</span><span class="p">()</span>

    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">G_rf</span><span class="p">,</span> <span class="s2">&quot;After Ricci Flow (graph)&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">draw_graph</span><span class="p">(</span>
        <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;club&quot;</span><span class="p">,</span> <span class="n">nodes_cmap</span><span class="o">=</span><span class="n">nodes_cmap</span>
    <span class="p">)</span>
    <span class="c1"># -----------------------------------</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=====  Compute Modularity &amp; ARI vs cutoff =====&quot;</span><span class="p">)</span>
    <span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span><span class="p">,</span> <span class="n">good_cut</span><span class="p">,</span> <span class="n">best_ari</span><span class="p">,</span> <span class="n">best_mod</span> <span class="o">=</span> <span class="n">check_accuracy</span><span class="p">(</span>
        <span class="n">G_rf</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;club&quot;</span><span class="p">,</span> <span class="n">eval_cut</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">plot_accuracy</span><span class="p">(</span><span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span><span class="p">,</span> <span class="n">save_path</span><span class="p">,</span> <span class="n">good_cut</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">user_threshold</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Threshold for surgery: &quot;</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The inserted value for threshold is not a floating point number.&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-  Apply surgery</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">perform_surgery</span><span class="p">(</span><span class="n">G_rf</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;club&quot;</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="n">user_threshold</span><span class="p">)</span>

    <span class="n">GraphDrawer</span><span class="p">(</span>
        <span class="n">G_rf</span><span class="p">,</span>
        <span class="s2">&quot;After Surgery&quot;</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">draw_graph</span><span class="p">(</span><span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;club&quot;</span><span class="p">,</span> <span class="n">nodes_cmap</span><span class="o">=</span><span class="n">nodes_cmap</span><span class="p">)</span>
    <span class="c1"># -----------------------------------</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Draw communities&quot;</span><span class="p">)</span>
    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">G_rf</span><span class="p">,</span> <span class="s2">&quot;Detected Communities&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">draw_communities</span><span class="p">(</span>
        <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;club&quot;</span><span class="p">,</span> <span class="n">nodes_cmap</span><span class="o">=</span><span class="n">nodes_cmap</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">best_mod</span><span class="p">,</span> <span class="n">best_ari</span></div>



<span class="kn">import</span><span class="w"> </span><span class="nn">community.community_louvain</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">community_louvain</span>  <span class="c1"># Louvain method</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">igraph</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ig</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">leidenalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">la</span>  <span class="c1"># Leiden method</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">networkx.algorithms.community</span><span class="w"> </span><span class="kn">import</span> <span class="n">girvan_newman</span>


<div class="viewcode-block" id="karate_club_comp">
<a class="viewcode-back" href="../karate_club.html#karate_club.karate_club_comp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">karate_club_comp</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare Louvain and Girvan-Newman community detection on the Zachary Karate Club graph.</span>

<span class="sd">    This function applies **Louvain** and **Girvan-Newman** algorithms to the</span>
<span class="sd">    Zachary Karate Club graph to detect communities. It evaluates both methods using:</span>

<span class="sd">    - **Modularity**: Measures the strength of the community structure.</span>
<span class="sd">    - **Adjusted Rand Index (ARI)**: Measures clustering accuracy compared to the ground truth.</span>

<span class="sd">    The function prints the modularity and ARI scores for both methods and returns them.</span>

<span class="sd">    :returns: A tuple containing:</span>
<span class="sd">        - **louvain_modularity** (*float*): Modularity score for Louvain clustering.</span>
<span class="sd">        - **louvain_ari** (*float*): ARI score for Louvain clustering.</span>
<span class="sd">        - **gn_modularity** (*float*): Modularity score for Girvan-Newman clustering.</span>
<span class="sd">        - **gn_ari** (*float*): ARI score for Girvan-Newman clustering.</span>
<span class="sd">    :rtype: tuple(float, float, float, float)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>

    <span class="c1"># --- Louvain ---</span>
    <span class="n">louvain_partition</span> <span class="o">=</span> <span class="n">community_louvain</span><span class="o">.</span><span class="n">best_partition</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">louvain_communities</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nb">frozenset</span><span class="p">([</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">louvain_partition</span> <span class="k">if</span> <span class="n">louvain_partition</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">louvain_partition</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="n">louvain_modularity</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">community</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">louvain_communities</span>
    <span class="p">)</span>
    <span class="n">louvain_ari</span> <span class="o">=</span> <span class="n">ARI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">louvain_partition</span><span class="p">,</span> <span class="s2">&quot;club&quot;</span><span class="p">)</span>

    <span class="c1"># --- Girvan-Newman ---</span>
    <span class="n">gn_hierarchy</span> <span class="o">=</span> <span class="n">girvan_newman</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">gn_partition</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gn_hierarchy</span><span class="p">)</span>  <span class="c1"># First split</span>
    <span class="n">gn_modularity</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">algorithms</span><span class="o">.</span><span class="n">community</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">gn_partition</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">gn_ari</span> <span class="o">=</span> <span class="n">ARI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">gn_partition</span><span class="p">,</span> <span class="s2">&quot;club&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Louvain Modularity: </span><span class="si">{</span><span class="n">louvain_modularity</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, Louvain ARI: </span><span class="si">{</span><span class="n">louvain_ari</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Girvan-Newman Modularity: </span><span class="si">{</span><span class="n">gn_modularity</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, Girvan-Newman ARI: </span><span class="si">{</span><span class="n">gn_ari</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">louvain_modularity</span><span class="p">,</span> <span class="n">louvain_ari</span><span class="p">,</span> <span class="n">gn_modularity</span><span class="p">,</span> <span class="n">gn_ari</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">modularity_rf</span><span class="p">,</span> <span class="n">ari_rf</span> <span class="o">=</span> <span class="n">karate_club_rf</span><span class="p">()</span>
    <span class="p">(</span><span class="n">louvain_modularity</span><span class="p">,</span> <span class="n">louvain_ari</span><span class="p">,</span> <span class="n">gn_modularity</span><span class="p">,</span> <span class="n">gn_ari</span><span class="p">)</span> <span class="o">=</span> <span class="n">karate_club_comp</span><span class="p">()</span>

    <span class="n">modularity_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">modularity_rf</span><span class="p">,</span> <span class="n">louvain_modularity</span><span class="p">,</span> <span class="n">gn_modularity</span><span class="p">]</span>
    <span class="n">ari_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">ari_rf</span><span class="p">,</span> <span class="n">louvain_ari</span><span class="p">,</span> <span class="n">gn_ari</span><span class="p">]</span>

    <span class="n">plot_comp_histo</span><span class="p">(</span><span class="n">modularity_values</span><span class="p">,</span> <span class="n">ari_values</span><span class="p">,</span> <span class="s2">&quot;KarateClubResults&quot;</span><span class="p">)</span>
</pre></div>

          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Fabbri L..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>