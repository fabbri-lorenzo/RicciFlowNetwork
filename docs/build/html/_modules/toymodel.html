<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>toymodel &#8212; Ricci Flow in Networks 01/03/2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=27fed22d" />
    <script src="../_static/documentation_options.js?v=fbff3254"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for toymodel</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">GraphRicciCurvature.OllivierRicci</span><span class="w"> </span><span class="kn">import</span> <span class="n">OllivierRicci</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="s2">&quot;/Users/lorenzofabbri/Downloads/Code/RicciFlowNetwork&quot;</span>
        <span class="p">)</span>  <span class="c1"># Substitute with your own path</span>
    <span class="p">)</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">utils.plot</span><span class="w"> </span><span class="kn">import</span> <span class="n">GraphDrawer</span><span class="p">,</span> <span class="n">plot_accuracy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">utils.surgery</span><span class="w"> </span><span class="kn">import</span> <span class="n">check_accuracy</span><span class="p">,</span> <span class="n">perform_surgery</span>


<div class="viewcode-block" id="create_SBM_graph">
<a class="viewcode-back" href="../toymodel.html#toymodel.create_SBM_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_SBM_graph</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a Stochastic Block Model (SBM) graph with 2 equal size communities.</span>

<span class="sd">    The sizes of the communities are predefined as 250, 250 (as it is in &quot;Community Detection on Networks with Ricci Flow&quot; by by Chien-Chun Ni et al.). A probability matrix defines</span>
<span class="sd">    the edge probabilities within and across the communities. This function also assigns community</span>
<span class="sd">    labels to the nodes in the graph.</span>

<span class="sd">    :returns: A NetworkX graph with community labels assigned to nodes.</span>
<span class="sd">    :rtype: networkx.Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">250</span><span class="p">]</span>
    <span class="n">p_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">stochastic_block_model</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">p_matrix</span><span class="p">)</span>

    <span class="c1"># Assign &quot;community&quot; labels to nodes</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sizes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s2">&quot;community&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">size</span>

    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="create_LFR_graph">
<a class="viewcode-back" href="../toymodel.html#toymodel.create_LFR_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_LFR_graph</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an Lancichinetti Fortunato Radicchi (LFR) benchmark graph.</span>

<span class="sd">    The graph has 500 nodes with specific degree and community size distributions.</span>
<span class="sd">    Community labels are then assigned to the nodes.</span>

<span class="sd">    :returns: A NetworkX graph with community labels assigned to nodes.</span>
<span class="sd">    :rtype: networkx.Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">LFR_benchmark_graph</span><span class="p">(</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>  <span class="c1"># Number of nodes</span>
        <span class="n">tau1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="c1"># Degree distribution exponent</span>
        <span class="n">tau2</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>  <span class="c1"># Community size distribution exponent</span>
        <span class="n">mu</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>  <span class="c1"># Low mixing parameter for strong community structure</span>
        <span class="n">min_community</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>  <span class="c1"># Minimum number of nodes in each community</span>
        <span class="n">max_community</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span>  <span class="c1"># Maximum number of nodes in each community</span>
        <span class="n">average_degree</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>  <span class="c1"># Average degree per node</span>
        <span class="n">max_degree</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>  <span class="c1"># Maximum degree per node</span>
        <span class="n">max_iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>  <span class="c1"># Maximum number of iterations for graph generation</span>
        <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>  <span class="c1"># Random seed for reproducibility</span>
    <span class="p">)</span>

    <span class="n">complex_list</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;community&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">complex_list</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">complex_list</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">complex_list</span><span class="p">,</span> <span class="s2">&quot;community&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>



<div class="viewcode-block" id="test_ricci_curvature">
<a class="viewcode-back" href="../toymodel.html#toymodel.test_ricci_curvature">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">test_ricci_curvature</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Ricci curvature of the given graph using Ollivier-Ricci method.</span>

<span class="sd">    This function initializes the Ollivier-Ricci curvature calculation on the input graph and computes</span>
<span class="sd">    the Ricci curvature using the Optimal Transport Distance (OTD) method.</span>

<span class="sd">    :param G: The graph to compute the Ricci curvature on.</span>
<span class="sd">    :type G: networkx.Graph</span>
<span class="sd">    :returns: The OllivierRicci instance containing computed Ricci curvature.</span>
<span class="sd">    :rtype: GraphRicciCurvature.OllivierRicci</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=====  Before Ricci Flow =====&quot;</span><span class="p">)</span>
    <span class="n">orc</span> <span class="o">=</span> <span class="n">OllivierRicci</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">exp_power</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">proc</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;OTD&quot;</span><span class="p">)</span>
    <span class="n">orc</span><span class="o">.</span><span class="n">compute_ricci_curvature</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">orc</span></div>



<div class="viewcode-block" id="test_ricci_flow">
<a class="viewcode-back" href="../toymodel.html#toymodel.test_ricci_flow">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">test_ricci_flow</span><span class="p">(</span><span class="n">orc</span><span class="p">,</span> <span class="n">iterations</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Ricci flow of the graph using Ollivier-Ricci method.</span>

<span class="sd">    This function applies the Ricci flow algorithm to the graph and updates the graph&#39;s curvature.</span>

<span class="sd">    :param orc: The OllivierRicci instance that has the initial Ricci curvature.</span>
<span class="sd">    :type orc: GraphRicciCurvature.OllivierRicci</span>
<span class="sd">    :returns: The updated graph after applying Ricci flow.</span>
<span class="sd">    :rtype: networkx.Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=====  Compute Ricci flow metric - Optimal Transportation Distance =====&quot;</span><span class="p">)</span>
    <span class="n">orc</span><span class="o">.</span><span class="n">compute_ricci_flow</span><span class="p">(</span><span class="n">iterations</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">orc</span><span class="o">.</span><span class="n">G</span></div>



<div class="viewcode-block" id="test_check_accuracy">
<a class="viewcode-back" href="../toymodel.html#toymodel.test_check_accuracy">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">test_check_accuracy</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute Modularity and Adjusted Rand Index (ARI) for different edge weight cutoffs.</span>

<span class="sd">    This function tests the community detection performance by checking modularity and ARI</span>
<span class="sd">    for different cutoff values applied to the graph.</span>

<span class="sd">    :param G: The graph on which the accuracy is tested.</span>
<span class="sd">    :type G: networkx.Graph</span>
<span class="sd">    :returns: Maximum weight, cutoff range, modularity, and ARI values.</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=====  Compute Modularity &amp; ARI vs cutoff =====&quot;</span><span class="p">)</span>
    <span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span> <span class="o">=</span> <span class="n">check_accuracy</span><span class="p">(</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;community&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span></div>



<div class="viewcode-block" id="test_perform_surgery">
<a class="viewcode-back" href="../toymodel.html#toymodel.test_perform_surgery">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">test_perform_surgery</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform edge surgery on the graph by removing edges with weight greater than a given threshold.</span>

<span class="sd">    The user is prompted to input a threshold value, and edges with weights greater than this threshold</span>
<span class="sd">    are removed from the graph.</span>

<span class="sd">    :param G: The graph on which the surgery is performed.</span>
<span class="sd">    :type G: networkx.Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=====  After Surgery =====&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">user_threshold</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Threshold for surgery: &quot;</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The inserted value for threshold is not a floating point number.&quot;</span><span class="p">)</span>
    <span class="c1"># Perform surgery, removing edges with weight &gt; threshold</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Performing surgery on edges...&quot;</span><span class="p">)</span>
    <span class="n">perform_surgery</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="n">user_threshold</span><span class="p">)</span></div>



<div class="viewcode-block" id="run_tests">
<a class="viewcode-back" href="../toymodel.html#toymodel.run_tests">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_tests</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run all tests including graph generation, Ricci curvature computation,</span>
<span class="sd">    accuracy checking, and surgery performance.</span>

<span class="sd">    The function allows the user to choose between generating a Stochastic Block Model (SBM) graph</span>
<span class="sd">    or an LFR benchmark graph. It then computes the Ricci curvature, performs Ricci flow, checks</span>
<span class="sd">    modularity and ARI, and performs edge surgery on the graph.</span>

<span class="sd">    :returns: None</span>
<span class="sd">    :rtype: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">graph_type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">1 - Stochastic Block Model graph </span><span class="se">\n</span><span class="s2">2 - LFR Benchmark graph&quot;</span>
                <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Insert the number corresponding to the type of graph you would like to have as a test: &quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">graph_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The inserted value must be 1 or 2&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The inserted value is not an integer.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">graph_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">create_SBM_graph</span><span class="p">()</span>
        <span class="n">save_path</span> <span class="o">=</span> <span class="s2">&quot;tests/ToyModelResults/SBM&quot;</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">elif</span> <span class="n">graph_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">create_LFR_graph</span><span class="p">()</span>
        <span class="n">save_path</span> <span class="o">=</span> <span class="s2">&quot;tests/ToyModelResults/LFR&quot;</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="c1"># -----------------------------------</span>
    <span class="n">orc</span> <span class="o">=</span> <span class="n">test_ricci_curvature</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">orc</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;Before Ricci Flow&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">draw_graph</span><span class="p">(</span>
        <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;community&quot;</span>
    <span class="p">)</span>
    <span class="c1"># -----------------------------------</span>
    <span class="n">G_rf</span> <span class="o">=</span> <span class="n">test_ricci_flow</span><span class="p">(</span><span class="n">orc</span><span class="p">,</span> <span class="n">iterations</span><span class="p">)</span>
    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">G_rf</span><span class="p">,</span> <span class="s2">&quot;After Ricci Flow&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">draw_graph</span><span class="p">(</span>
        <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;community&quot;</span>
    <span class="p">)</span>
    <span class="c1"># -----------------------------------</span>
    <span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span> <span class="o">=</span> <span class="n">test_check_accuracy</span><span class="p">(</span><span class="n">G_rf</span><span class="p">)</span>
    <span class="n">plot_accuracy</span><span class="p">(</span><span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span>
    <span class="c1"># -----------------------------------</span>
    <span class="n">test_perform_surgery</span><span class="p">(</span><span class="n">G_rf</span><span class="p">)</span>
    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">G_rf</span><span class="p">,</span> <span class="s2">&quot;After Surgery&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">draw_graph</span><span class="p">(</span>
        <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;community&quot;</span>
    <span class="p">)</span>
    <span class="c1"># -----------------------------------</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Drawing communities&quot;</span><span class="p">)</span>
    <span class="n">GraphDrawer</span><span class="p">(</span><span class="n">G_rf</span><span class="p">,</span> <span class="s2">&quot;Detected Communities&quot;</span><span class="p">,</span> <span class="n">save_path</span><span class="p">)</span><span class="o">.</span><span class="n">draw_communities</span><span class="p">(</span>
        <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;community&quot;</span>
    <span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">run_tests</span><span class="p">()</span>
</pre></div>

          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Fabbri L..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>