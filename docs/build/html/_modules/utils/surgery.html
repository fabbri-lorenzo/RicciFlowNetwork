<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>utils.surgery &#8212; Ricci Flow in Networks 01/03/2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=fbff3254"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for utils.surgery</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">community.community_louvain</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">community_louvain</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn</span><span class="w"> </span><span class="kn">import</span> <span class="n">preprocessing</span><span class="p">,</span> <span class="n">metrics</span>

<span class="n">dcp</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># decimal precision</span>


<div class="viewcode-block" id="ARI">
<a class="viewcode-back" href="../../utils.html#utils.surgery.ARI">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ARI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">clustering</span><span class="p">,</span> <span class="n">clustering_label</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Adjust Rand Index (clustering accuracy) of &quot;clustering&quot; with &quot;clustering_label&quot; as ground truth.</span>

<span class="sd">    :param G: A graph with node attribute &quot;clustering_label&quot; as ground truth.</span>
<span class="sd">    :type G: networkx.Graph</span>
<span class="sd">    :param clustering: Predicted community clustering.</span>
<span class="sd">    :type clustering: dict, list, or list of sets</span>
<span class="sd">    :param clustering_label: Node attribute name for ground truth.</span>
<span class="sd">    :type clustering_label: str</span>
<span class="sd">    :returns: Adjust Rand Index for predicted community.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">complex_list</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">clustering_label</span><span class="p">)</span>
    <span class="n">le</span> <span class="o">=</span> <span class="n">preprocessing</span><span class="o">.</span><span class="n">LabelEncoder</span><span class="p">()</span>
    <span class="n">y_true</span> <span class="o">=</span> <span class="n">le</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">complex_list</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clustering</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># python-louvain partition format</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">clustering</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">complex_list</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clustering</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">set</span><span class="p">):</span>
        <span class="c1"># networkx partition format</span>
        <span class="n">predict_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clustering</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">}</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">predict_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">complex_list</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clustering</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># sklearn partition format</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">clustering</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">INVALID CLUSTERING TYPE, couldn&#39;t compute ARI successfully.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">metrics</span><span class="o">.</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span></div>



<div class="viewcode-block" id="perform_surgery">
<a class="viewcode-back" href="../../utils.html#utils.surgery.perform_surgery">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">perform_surgery</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;community&quot;</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple surgery function that removes the edges with weight above a threshold.</span>

<span class="sd">    :param G: A graph with ``weight`` as the Ricci flow metric to cut.</span>
<span class="sd">    :type G: networkx.Graph</span>
<span class="sd">    :param weight: The edge weight used as the Ricci flow metric. Defaults to &quot;weight&quot;.</span>
<span class="sd">    :type weight: str</span>
<span class="sd">    :param cut: Manually assigned cutoff point.</span>
<span class="sd">    :type cut: float or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">cut</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Cut value should be greater than 0.&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cut</span><span class="p">:</span>
        <span class="n">cut</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.6</span> <span class="o">+</span> <span class="mf">1.0</span>  <span class="c1"># Guess a cut point as default</span>

    <span class="n">to_cut</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="n">weight</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cut</span><span class="p">:</span>
            <span class="n">to_cut</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*************** Surgery ****************&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Cut </span><span class="si">%d</span><span class="s2"> edges.&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_cut</span><span class="p">))</span>
    <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">to_cut</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Number of nodes now: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Number of edges now: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">())</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* ARI now: </span><span class="si">%f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">ARI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">clustering_label</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;****************************************&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="check_accuracy">
<a class="viewcode-back" href="../../utils.html#utils.surgery.check_accuracy">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">check_accuracy</span><span class="p">(</span>
    <span class="n">G_origin</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;community&quot;</span><span class="p">,</span> <span class="n">eval_cut</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the clustering quality while cutting edges with a given weight using different thresholds.</span>

<span class="sd">    This function iteratively removes edges based on a weight threshold (Ricci flow metric) and evaluates</span>
<span class="sd">    the clustering results using modularity and Adjusted Rand Index (ARI). If `eval_cut` is enabled,</span>
<span class="sd">    it also estimates a &quot;good&quot; cut threshold by detecting significant drops in modularity.</span>

<span class="sd">    :param G_origin: A graph with ``weight`` as the Ricci flow metric used for edge removal.</span>
<span class="sd">    :type G_origin: networkx.Graph</span>
<span class="sd">    :param weight: The edge weight attribute used as the Ricci flow metric. Defaults to ``&quot;weight&quot;``.</span>
<span class="sd">    :type weight: str</span>
<span class="sd">    :param clustering_label: Node attribute name for ground truth communities. Defaults to ``&quot;community&quot;``.</span>
<span class="sd">    :type clustering_label: str</span>
<span class="sd">    :param eval_cut: Whether to compute an estimated optimal cut threshold based on modularity drops. Defaults to ``False``.</span>
<span class="sd">    :type eval_cut: bool</span>

<span class="sd">    :returns: A tuple containing:</span>
<span class="sd">        - **maxw** (*float*): Maximum edge weight value in the graph.</span>
<span class="sd">        - **cutoff_range** (*numpy.ndarray*): Array of tested cutoff values for edge removal.</span>
<span class="sd">        - **modularity** (*list[float]*): Modularity values at each cutoff.</span>
<span class="sd">        - **ari** (*list[float]*): ARI values at each cutoff.</span>
<span class="sd">        - (**Optional**) **good_cut** (*float*): Estimated best cutoff based on modularity drop (only if ``eval_cut=True``).</span>
<span class="sd">        - (**Optional**) **best_ari** (*float*): Highest ARI value achieved (only if ``eval_cut=True``).</span>
<span class="sd">        - (**Optional**) **best_mod** (*float*): Modularity value at best_ari (only if ``eval_cut=True``).</span>

<span class="sd">    :rtype: tuple</span>
<span class="sd">        - If ``eval_cut=False`` → ``(float, numpy.ndarray, list[float], list[float])``</span>
<span class="sd">        - If ``eval_cut=True`` → ``(float, numpy.ndarray, list[float], list[float], float, float, float)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G_origin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">maxw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">cutoff_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">maxw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.025</span><span class="p">)</span>

    <span class="n">best_ari</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">best_cutoff</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">cutoff</span> <span class="ow">in</span> <span class="n">cutoff_range</span><span class="p">:</span>
        <span class="n">edge_trim_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="n">weight</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="n">edge_trim_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edge_trim_list</span><span class="p">)</span>

        <span class="c1"># Get connected component after cut as clustering</span>
        <span class="n">clustering</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span>
        <span class="p">}</span>

        <span class="c1"># Compute modularity and ari</span>
        <span class="n">modularity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">community_louvain</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span><span class="n">clustering</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
        <span class="n">current_ari</span> <span class="o">=</span> <span class="n">ARI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">clustering</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="n">clustering_label</span><span class="p">)</span>
        <span class="n">ari</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_ari</span><span class="p">)</span>

        <span class="c1"># Update best ARI and corresponding cutoff</span>
        <span class="k">if</span> <span class="n">current_ari</span> <span class="o">&gt;</span> <span class="n">best_ari</span><span class="p">:</span>
            <span class="n">best_ari</span> <span class="o">=</span> <span class="n">current_ari</span>
            <span class="n">best_cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>

    <span class="k">if</span> <span class="n">eval_cut</span><span class="p">:</span>  <span class="c1"># Search for a good cut looking at modularity</span>
        <span class="n">good_cut</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">mod_last</span> <span class="o">=</span> <span class="n">modularity</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">drop_threshold</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.01</span>  <span class="c1"># at least drop this much to be considered as a drop for good_cut</span>
        <span class="p">)</span>

        <span class="c1"># search for drop in modularity</span>
        <span class="n">drops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">modularity</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">mod_now</span> <span class="o">=</span> <span class="n">modularity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mod_last</span> <span class="o">&gt;</span> <span class="mf">1e-4</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mod_now</span> <span class="o">/</span> <span class="n">mod_last</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">drop_threshold</span><span class="p">:</span>
                <span class="n">drops</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cutoff_range</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">mod_last</span><span class="p">))</span>

            <span class="n">mod_last</span> <span class="o">=</span> <span class="n">mod_now</span>

        <span class="c1"># Find the tuple with the highest modularity value in drops</span>
        <span class="n">best_drop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">drops</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Extract the cutoff value and modularity value</span>
        <span class="n">good_cut</span> <span class="o">=</span> <span class="n">best_drop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">best_mod</span> <span class="o">=</span> <span class="n">best_drop</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Best ARI: </span><span class="si">{</span><span class="n">best_ari</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">dcp</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">, with cutoff = </span><span class="si">{</span><span class="n">best_cutoff</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">dcp</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="se">\n</span><span class="s2">Guessed cutoff = </span><span class="si">{</span><span class="n">good_cut</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">dcp</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span><span class="p">,</span> <span class="n">good_cut</span><span class="p">,</span> <span class="n">best_ari</span><span class="p">,</span> <span class="n">best_mod</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Best ARI: </span><span class="si">{</span><span class="n">best_ari</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">dcp</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">, with cutoff = </span><span class="si">{</span><span class="n">best_cutoff</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">dcp</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">maxw</span><span class="p">,</span> <span class="n">cutoff_range</span><span class="p">,</span> <span class="n">modularity</span><span class="p">,</span> <span class="n">ari</span></div>



<div class="viewcode-block" id="get_best_cut">
<a class="viewcode-back" href="../../utils.html#utils.surgery.get_best_cut">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_best_cut</span><span class="p">(</span><span class="n">G_origin</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the best edge removal cutoff threshold to maximize clustering accuracy (ARI).</span>

<span class="sd">    This function iteratively removes edges based on a weight threshold (e.g., Ricci flow metric)</span>
<span class="sd">    and evaluates the resulting clustering accuracy using the Adjusted Rand Index (ARI).</span>
<span class="sd">    The best cutoff is selected as the one that yields the highest ARI.</span>

<span class="sd">    :param G_origin: A graph where edges have an attribute ``weight`` used as a removal criterion.</span>
<span class="sd">    :type G_origin: networkx.Graph</span>
<span class="sd">    :param weight: The edge weight attribute used as the removal metric. Defaults to ``&quot;weight&quot;``.</span>
<span class="sd">    :type weight: str</span>
<span class="sd">    :param clustering_label: Node attribute name for ground truth communities. Defaults to ``&quot;value&quot;``.</span>
<span class="sd">    :type clustering_label: str</span>

<span class="sd">    :returns: The cutoff threshold that results in the highest ARI.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G_origin</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">maxw</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">cutoff_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">maxw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.025</span><span class="p">)</span>

    <span class="n">best_ari</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">best_cutoff</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">cutoff</span> <span class="ow">in</span> <span class="n">cutoff_range</span><span class="p">:</span>
        <span class="n">edge_trim_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">G</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">][</span><span class="n">weight</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">:</span>
                <span class="n">edge_trim_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
        <span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edge_trim_list</span><span class="p">)</span>

        <span class="c1"># Get connected component after cut as clustering</span>
        <span class="n">clustering</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span>
        <span class="p">}</span>

        <span class="n">current_ari</span> <span class="o">=</span> <span class="n">ARI</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">clustering</span><span class="p">,</span> <span class="n">clustering_label</span><span class="o">=</span><span class="n">clustering_label</span><span class="p">)</span>

        <span class="c1"># Update best ARI &amp; best cutoff</span>
        <span class="k">if</span> <span class="n">current_ari</span> <span class="o">&gt;</span> <span class="n">best_ari</span><span class="p">:</span>
            <span class="n">best_ari</span> <span class="o">=</span> <span class="n">current_ari</span>
            <span class="n">best_cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>

    <span class="k">return</span> <span class="n">best_cutoff</span></div>

</pre></div>

          </div>
          
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Fabbri L..
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>